#+TITLE: EDI
#+OPTIONS: creator:nil author:nil H:4 toc:2 num:2
#+SEQ_TODO: OPEN IDEA ASSIGNED TEST | DONE
#+HTML_HEAD: <link href="css/bootstrap.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/bootstrap-responsive.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/jquery.tocify.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/custom.css" rel="stylesheet" media="screen">

* Ideas, Todos
:PROPERTIES:
:ARCHIVE: %s_archive::* Todos
:END:
** Features
*** OPEN hubelmeter                                                    :c3po:
*** OPEN jabber bot
- user same msg exchange as irc bot

- Possible routing keys: "jabber.recv.raw" "jabber.send.raw"

*** OPEN mail bot
- wie jabber bot nur ueber email
- nuetzlich auch fuer den notify: user service
- unauthenticated mail?!

*** OPEN calendar integration: source
- Repeadedly parse calendar files. Idealy ics. Load from caldav?
  google calendar?

**** Variants
***** Calendar Commands
- Im Kallender stehen edi commands. Diese zu den eingestellten Zeiten
  injecten.

Quasi alternative zu CRON.

irq0: Damit koennte ich mir meinen Wecker bauen..

***** Events
- Event :: Something is going to happen at a point in time. Wie das
           digitale Zeitalter..

Per TTS, Text notification, IRC, Jabber whatever hinweisen
*** OPEN calendar integration: sink/proc
- siehe auch [[(conj 'seri hackerfyhstuck)]]
- daily events im irc topic
- events auf wallhack anzeigen
- notification mails?
  - hackerfryhstyck automatisch ankuendigen
- kallender abonierbar
- [[(conj 'seri hackerfyhstuck)]] traegt leute zum event ein
- ETAs als calendar events
*** OPEN graphite integration
Es macht sinn sensoren an ein graphite zu knoten. Dadruch bekommt man
gleich daten über zeit und eine ganze reihe von funktionen über diese
daten.

Daten aus graphite gekommt man über die =?render= HTTP Schnittstelle
in den gängigsten formaten wie JSON, CSV, SVG, PNG.

**** Mögliche Umsetzungen
***** RPC
AMQP RPC Pattern implementieren
***** PubSub
Subscribe periodic sensor updates
***** Nicht integrieren
Direkt mit Graphite sprechen
*** OPEN thehonestbookoftruth: support !eta with dates
Support:
- !eta 2014-03-12 20:00
- !eta Tomorrow 20:00
- !eta Morgen 20:00
- !eta Mittwoch 20:00

Retain support for times only. Use today as date
- !eta 20:00
*** OPEN set irc topics/modeline
- Calendar events like smalltalks
- something like the emacs modeline?
*** DONE dhcp lease loest login aus                                    :c3pb:
- private exchange fuer dhcp messages
  - vom router aus eintueten
- tool um mac adressen usern zuzuweisen
- tool um diese user einzuloggen
*** OPEN voice recognition
**** Idea
To speech to text. At least in english. Perform natural language
processing to extract meaning. Generate commands.

**** Tools
***** pocketsphinx
pocketsphinx is a cpp implementation of sphinx, smaller and not java.

- debian/ubuntu packages: https://launchpad.net/~dhuggins/+archive/cmusphinx
- transformations:
  - we can't recognize users by voice.
  - "!say" not nice to say. instead:
    - "user command <user> <command>"
    - "UC <user> <command>"
    - "command <command>
    - "do <command>"

- "EDI: command say foo"
- "EDI: user command seri login"
- "EDI: user command seri logout"
- "EDI <TONE> "

***** wit.io
- natural language processing web app
- does the text -> meaning part
- exports sphinx language models

**** integration
***** msg
- recv :: voice recognition with some custom transformations
- send :: notify.audio?
***** asterisk
- .. we can recocnize users by callerid
- login by phone?
- desktop edi voice clients based on SIP

** Architecture Changes
** Janitor Tasks
*** ASSIGNED put asterisk container somewhere                       :@irq0:
Running on janelane. Put on some server. Keep sipgate credentials
private.
* Documentation
The core of the architecture is the rabbitmq amqp message server.
Every pice of code connects in some way to it.

Most services share a couple of well defined exchanges. See the
[[Well-defined Exchanges]] for a description.

** Setup
In theory(tm). Expect some settings to still be hard coded somewhere.

1. Install AMQP Server. Best use RabbitMQ
2. git clone this repo
3. Create symlinks from =sv/available= to =sv/enabled= for the desired
   subsystems to run
3. ...
4. Start EDI with =run=

** Glossary
- source :: Apps that only/mainly produce messages
- sink :: Apps that only/mainly consume messages
- processor :: Apps that transform messages. Consume -> Produce.
- bot :: Consumer/Producer that add external/foreign interfaces to the
         system. Like IRC.

** Well-defined Exchanges
https://git.c3pb.de/c3pb/subraum-automatisierung/blob/master/doc/exchanges.jpeg

*** msg
Raw messages received from somewhere. This should be something that
can be parsed to a command.

Type: topic

**** Routing Keys
In general: protocol.bot-name.{send,recv,presence}.channel

 * irc.EDI.recv.#c3pb.sh
 * irc.EDI.send.#c3pb.sh
 * irc.EDI.presence
**** Messages
***** #.send.*
Content-Type: application/json

- msg :: Message body
- user :: Destination user

Content-Type: text/plain
body: Message
***** #.recv.*
Content-Type: application/json
- msg :: Message body
- user :: Message sender
**** Processors
***** parse-commands.py
Transform =!<command>= to *cmd* Messages. (See *cmd* Exchange)

**** Bots
***** IRC Bot - mqbot.py
IRC -> MQ, MQ -> IRC

**** Sinks

**** Sources

*** cmd
Messages that do something :)

Type: topic

**** Known routing Keys

***** TTS
- tts
- say
- forune
***** Actor Service
- act
***** subinit
- telinit
- runlevel
***** thehonestbookoftruth
- login
- logout
- logout-all
- ul
- eta
- uneta
***** What every command should implement:
- list
- help

**** Messages
Content-Type: application/json

- cmd :: Usually the same as the routing key when parsed from *msg*
         Messages. Could be different. Not sure why I include it. The
         clojure tools use the to dispatch handlers..
- args :: Argument string.
- user :: User that send the command. The command may use this to log.
- src :: Command origin. Replies will be send here with the word
         /recv/ replaced by /send/. If the src is invalid replies will
         just vanish :)
- dst :: Where to put the result. This option is strictly optional.
         Implement a same default like reply based on =src= or default destination.

**** Sources
**** Sinks
**** Processors
***** tts
Transform /tts/ *cmd* Messages to notification audio messages.

Text -> Audio file.

***** Simple Actor Service - act.py
Map /act/ commands to actors.

Example:
venti on => 433Mhz sender, payload 11111 1 1

See =act_433mhz= exchange for the 433Mhz actor implementation.

*** notify
*Sink* exchage for notifications.

**** Routing Keys
- audio
- text

**** Sinks
***** mplayer one-liner
#+BEGIN_SRC sh
amqp-consume --url="amqp://mopp" --exchange="notify" --routing-key="audio" mplayer -
#+END_SRC

**** Messages
Content-Type depending on exchange keys. Should be directly usable by
the sink (e.g mp3 file to hand over to mplayer).

*** =act_433mhz=                                                  :private:
*Sink* exchange to signal 433mhz transmitter.

Type: fanout

**** Messages
Commandline arguments for `rcswitch-pi`.

**** Sinks
*** subinit                                                       :private:
*Sink* exchange for subinit messages

Type: topic
**** Messages
Content-type: text/plain

Must always contain the same as the routing key.
**** Sinks
***** subinit-rc
Launch scripts on subinit messages consumed. Feel similar to sysvinit
scripts and runlevels

** Software, Libs, etc.
*** Debian packages
- rabbitmq-server (debian testing ist aktuell genug)
- python-pika
- python-amqplib
- amqp-tools

*** docker
For development docker seemes a good choice:
#+BEGIN_SRC sh
sudo docker run -p :5672 -p :15672 -v /scratch/docker-data/rabbitmq:/var/lib/rabbitmq/mnesia f04150b0661e
sudo docker build github.com/mikaelhg/docker-rabbitmq.git
#+END_SRC

Note that the exchanges are configured by hand..

Use =mopp=, running on the dell netbook.
*** Useful libraries

** Development
Install requirements. Setup exchanges in rabbitmq. The web interfaces
comes in handy here ;)

*** Repository Organization
- src :: Tools that only *publish* messages
- sink :: Tools that only *consume* messages
- proc :: Tools that *consume* and *publish* with some kind of
          processing going on
- bot :: Adapter to other protocols like IRC. *publisher* and *consumer*
- misc :: Useful stuff for testing, reference, whatever. Configuration
          files for external tools like asterisk
- sv :: Contains =available= and =enabled= directories. When EDI is
        started with the =run= script, start subsystems linked to
        =enabled= directory.
- log :: Log output for =sv/enabled= daemons.

Most larger tools are subtree merged from elsewhere. This repo is kind
of the collected deployment branch.

Have something to add? Let me pull your repo!

*** External Documentation
- [[http://www.rabbitmq.com/getstarted.html][Must read rabbitmq tutorial - covers all the basic use cases]]

*** Libraries
**** Python
- pika :: http://pika.readthedocs.org/en/latest/ Documented, Async lib
- amqplib :: simpler non-threaded library; documentation shipped in
             the .py files. Which are quite readable ;)

**** Commandline
- amqp-tools :: Make sure you get the recent ones. Debian testing
                works quite well. Debian stable not so.

**** Clojure

- langohr :: http://clojurerabbitmq.info/ Excellent library.

#+BEGIN_HTML
<script src="js/jquery.js"></script>
<script src="js/jquery-ui.js"></script>
<script src="js/jquery.tocify.js"></script>
<script src="js/bootstrap.js"></script>
<script src="js/custom.js"></script>
#+END_HTML
n
