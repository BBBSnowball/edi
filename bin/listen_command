#!/usr/bin/env python
# -*- coding: utf-8 -*-


import argparse
import pika
import sys
import time
import json
import re
import os
import subprocess
import logging
import traceback

cmds = {}

def make_cmd_inspect(config):
    def cmd_inspect(*args):
        return json.dumps(config)
    return cmd_inspect

def make_cmd_exec(cmd, app):
    def do_exec(data):
        stdin = output_formatter(data)
        env = os.environ
        env["EDI_CMD"] = cmd

        p = subprocess.Popen(app,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             stdin=subprocess.PIPE,
                             env=env)

        stdout, stderr = p.communicate(input=stdin)

        print "#### Command \"{}\"output: STDOUT".format(cmd)
        print (stdout or "")
        print "#### Command \"{}\"output: STDERR".format(cmd)
        print (stderr or "")

        return stdout

    return do_exec


def reply_dst(cmd):
    if cmd.has_key("src"):
        return cmd["src"].replace("recv", "send")
    else:
        return "irc.EDI.send._channel_" # TODO: use loev as fallback?

# TODO replace with loev
def emit_reply(orig_cmd, chan, msg):
    key = reply_dst(orig_cmd)

    print "---> [%r] %r" % (key, msg)

    chan.basic_publish(exchange="msg",
                       routing_key=key,
                       body=msg,
                       properties=pika.BasicProperties(
                           content_type="text/plain",
                           delivery_mode=2))


def cmd_callback(chan, method, props, body):
    print "<--- [%r] %r" % (method.routing_key, body)

    if props.content_type == "application/json":
        d = json.loads(body)

        try:
            cmd = d["cmd"]
            args = d["args"].split(None, 1)

            func = cmds[d["cmd"]]

            print "~~~~ Dispatching cmd \"{}\" to function: {}".format(cmd, func)
            ret = func(d)
            if ret:
                emit_reply(d, chan, ret)

        except Exception, e:
            print "~~~~ EXCEPTION in callback: ", e
            traceback.print_exc()

def output_formatter(x):
    return str(x)

def output_formatter_awkfriendly(x):
    return "\n".join("{}\x1E{}".format(k,str(v)) for k,v in x.iteritems())

def output_formatter_onlyargs(x):
    return x["args"]

def NameString(v):
    regex = r"^(\w+)$"
    try:
        return re.match(regex, v).group(0)
    except:
        raise ArgumentTypeError("Must match {}".format(regex))

def AssignmentString(v):
    regex = r"^(\w+)=(\w+)$"
    try:
        m = re.match(regex, v)
        return (m.group(1), m.group(2),)
    except:
        raise ArgumentTypeError("Must match {}".format(regex))

def parse_args(args=None):
       parser =argparse.ArgumentParser()

       parser.add_argument("--cmd",
                           action='append',
                           type=NameString,
                           required=True,
                           help="Command to register. Repeat for multiple commands")
       parser.add_argument("--cmd-args",
                           action="append",
                           type=AssignmentString,
                           required=False,
                           help="Specify command's argument type. Default is 'none'. Currently this option only changes the data returned by the implicit 'inspect' command. Example: --cmd-args weather=none")
       parser.add_argument("--name",
                           required=True,
                           type=NameString,
                           help="Name of the command handler")
       parser.add_argument("--description",
                           required=True,
                           help="Help command text")
       parser.add_argument("--data",
                           choices=("json", "awkfriendly", "onlyargs"),
                           default="json",
                           help="Format of data the handler script gets through stdin. Default: json")
       parser.add_argument("--exe",
                           required=True,
                           help="Program to call for each recvd command")

       result = parser.parse_args(args)

       # transform cmd_args to dict with missing set to defaults
       result.cmd_args = dict(result.cmd_args)

       for cmd in set(result.cmd) - set(result.cmd_args.keys()):
           result.cmd_args[cmd] = "none"

       result.config = {
           "app" : result.name,
           "descr" : result.description,
           "cmds" : {
               cmd : {
                   "descr" : result.description,
                   "args" : result.cmd_args[cmd],
               }
               for cmd in result.cmd
           }
       }

       return result

def main():
    logging.basicConfig()

    args = parse_args()
    print args

    amqp_server = os.getenv("AMQP_SERVER") or "localhost"
    conn = pika.BlockingConnection(pika.ConnectionParameters(amqp_server))
    chan = conn.channel()

    pika_logger = logging.getLogger('pika')
    pika_logger.setLevel(logging.INFO)


    global output_formatter
    if args.data == 'awkfriendly':
        output_formatter = output_formatter_awkfriendly
    elif args.data == 'onlyargs':
        output_formatter = output_formatter_onlyargs

    exchange = "cmd"
    queue = "generic_listen_command__{}".format(args.name)

    def init_dispatch_table():
        global cmds
        cmds["inspect"] = make_cmd_inspect(args.config)

        for cmd in args.cmd:
            cmds[cmd] = make_cmd_exec(cmd, args.exe)

    def setup():
        keys = ["inspect"] + list(args.cmd)
        print "---- Using queue:", queue
        print "---- Binding routing keys:", ", ".join(keys)

        chan.queue_declare(queue=queue,
                           durable=True,
                           auto_delete=True)

        for k in keys:
            chan.queue_bind(exchange=exchange,
                            queue=queue,
                            routing_key=k)

        chan.basic_consume(cmd_callback,
                           queue=queue,
                           no_ack=True)

    def run():
        print "---- Waiting for messages:"
        chan.start_consuming()

    def teardown():
        conn.close()

    try:
        setup()
        init_dispatch_table()
        run()
    except KeyboardInterrupt:
        pass
    finally:
        teardown()


if __name__ == "__main__":
    main()
