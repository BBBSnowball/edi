#+TITLE: EDI
#+OPTIONS: creator:nil author:nil H:6 toc:2 num:2
#+SEQ_TODO: OPEN IDEA ASSIGNED TEST | DONE
#+HTML_HEAD: <link href="css/bootstrap.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/bootstrap-responsive.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/jquery.tocify.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/custom.css" rel="stylesheet" media="screen">


* Ideas, Todos
** Features
*** OPEN User Notifications
- Im LDAP gibt es eine liste mit wegen einen user zu notifien
  - IRC nick
  - jabber id
  - twitter account (@foo)
  - email
- Notifications werden "reliable" zugestellt. Irgendwo kommt die
  notification an
- Message exchange und consumer sagen nack, wenn nicht zustellbar.
  Z.B. IRC offline
- Aehlich wie die notify exchange, audio fuer shouts in den subraum
-
*** OPEN guess commands                                                :c3po:
- see =thomas.py=, =pr.py= auf cube

- aus normalem text informationen gewinnen
- In etwa "mach mal licht an" -> "cmd bulb on"

*** OPEN hubelmeter                                                    :c3po:
*** OPEN big red button / klotz
- hardware button loest 'bigredbutton' command aus?

- Oder: Es können ja durchaus mehrere dinge einen big red button gebrauchen
- Vielleich ein button exchange einrichten auf dem verschiedene dienste
  lauschen können?
- Mehrere Buttons?
- Prototyp: Button exchange, Button an raspberry pie?

**** Story
Pizza Bestellung endet in 5 minuten. Countdown läuft. Stoppen? Drück
den button irgendwo im Raum. Zahlenkombination eingeben? Button an der
Decke?

  - Bei der Pizza Bestellung angeben? Nur stoppbar durch eingeben von
    31337 auf'm PIN Pad?
    - Pizza daemon wartet auf button 31337 messages..

*** OPEN jabber bot
- user same msg exchange as irc bot

- Possible routing keys: "jabber.recv.raw" "jabber.send.raw"

*** OPEN mail bot
- wie jabber bot nur ueber email
- nuetzlich auch fuer den notify: user service
- unauthenticated mail?!

*** OPEN irc reader
**** assign voices to each participant
***** parameters
- speed
- pitch
- voice: lea, julia, kenny...
**** participants can change voices

*** OPEN calendar integration - ics?
- Repeadedly parse calendar files. Idealy ics. Load from caldav?
  google calendar?

**** Variants
***** Calendar Commands
- Im Kallender stehen edi commands. Diese zu den eingestellten Zeiten
  injecten.

Quasi alternative zu CRON.

irq0: Damit koennte ich mir meinen Wecker bauen..

***** Events
- Event :: Something is going to happen at a point in time. Wie das
           digitale Zeitalter..

Per TTS, Text notification, IRC, Jabber whatever hinweisen
*** ASSIGNED pizza / essen / f00d                               :@hej:c3po:
*** ASSIGNED actor service / rule engine                              :@irq0:

currently a simple python script to map things like 'act bulb on' to
messages on the =act_433_mhz= queue

Idealy something with a rule engine:
- First user logged in: initiate startup sequence.
- Last user log out initiate


In the basic incarnation:
Map 'act' messages to actors. /act/ messages are something a user
can grasp, e.g /act venti on/. actors are something specific having
their own actor exchanges, e.g /act_433_mhz/ where messages contain
the commands for the sender as payload.
**** Idee
- Jedes event transformiert den aktuellen system state in einen neuen
  (clojure swap! semantik)
- Ändern des systemstates stösst die rule engine an
- Regeln verändern den state nicht (direkt). Können aber events
  emiten.
- State änderungen sind atomar. Ein event verändert. Andere events
  warten die änderungen ab. Änderungen sind ganz oder garnicht.
- Rule engine ausführungen immer auf neuen state. Rule engine
  ausführungen sind unabhängig voneinander
- Was ist mit aktoren?
  - State änderung muss irgendwie auch aktoren triggern können..
  - Hm.
  - State change funktionen für bestimmte events?
    - führen auch aktionen aus?

  - should-be relation:
    - event sagt "an", state sagt "aus" -> an aktion generieren
    - event sagt "an", state sagt "an" -> nop

      #+BEGIN_EXAMPLE
EVENT -> OLD STATE -> STATE CHANGE -> NEW STATE
                       -> ACTIONS

EVENT -> OLD STATE -> STATE CHANGE -> NEW STATE
                                   -> DIFFERENCE OLD NEW
                                   -> ACTIONS

      #+END_EXAMPLE
- Fakten, konfiguration
  - aktor name zu triggernes foo
  - 'act bulb on' -> msg =11111 1 on= an =act_433mhz= exchange.

- =(state-change old)=

*** ASSIGNED openhab integration                                  :@snowball:
*** ASSIGNED music player daemon                           :@snowball:c3po:
- mpd commands als messages
- Story: Ein EDI MQ command kann verschiedene music player daemons steuern
- Probleme
  - Mehrere mpds unterstützen; gleichzeitig steuern?
*** TEST presence: eta login                                        :@irq0:
Commands: !ul, !eta, !login, !logout

- cmd exchange consumer/producer
- store login, eta state somewhere

Implemented: [[proc/thehonestbookoftruth]]

*** TEST dmx actor                                        :@grollicus:c3po:
See =cube:/var/git/c3po/dmx=. DMX is connected to the serial port.

Example code:
#+BEGIN_SRC python
 #!/usr/bin/python

 import sys
 import serial

 ser = serial.Serial('/dev/dmx', 38400, timeout=1)

 ser.write("B1")

 ser.close()
#+END_SRC

There is also a dmx jsonrpc server:
=cube:/var/git/c3po/jsonrpcdmx=

*** DONE scheduled messages                                         :@irq0:
- hourly audio messages
- web gui?
- clojure + quarz scheduler?

Implementation: [[src/shouts]]
cronjob + amqp-tools + mp3 files

mp3 files found on cube..
*** DONE shutdown/startup                                           :@irq0:
Veralgemeinert implementiert: Init mit runlevels.

Reagiert auf Commands:
- telinit ::  Runlevel ändern
- runlevel :: Aktuelles runlevel zurückgeben


Emitiert Messages auf in der =subinit= Exchange.
Format: =rc.RUNLEVEL.ACTION=


Runleveländerungen (z.B 0 -> 4) generieren Events: 1 start, 2 start, 3
start, 4 start.

Runlevels sind dazu gedacht, um den Subraum auch nur "halb"
anzuschalten zu können. Beispielsweise ohne Mamestation.

**** Tool: subinit-rc
Tool um für subinit Messages Scripts zu starten. Aufgebaut wie rc*.d
runlevel scripts.

Skripts werden mit run-parts gestartet und bekommen die ACTION als
ersten Parameter

*** DONE text to speech command                                     :@irq0:
- listen for tts, say, fortune commands
- text to speech messages
- put mp3 files in notify exchange with key audio

Actually two implementations. One pico2wave in the EDI repo and one
based on the old acapella-group web scripting.
*** DONE irc bot                                                    :@irq0:
- IRC receive -> msg exchange with key irc.recv.raw
- msg exchange with key irc.send.raw -> IRC send
*** DONE 433MHz actor                                               :@irq0:
=act_433mhz= exchange

- consumer on raspberrypi
- message payload = commandline arguments to rcswitch tool

*** User Authentication
- irc nick <-> subraum LDAP?
- ueberhaupt noetig?
**** ASSIGNED irc bot antwortet nur auf op                         :@irq0:
- bot: only answer to users having op? (TODO)
*** Notify sink

**** text
=routing_key=text= messages.

***** DONE libnotify sink                                         :@irq0:
***** OPEN text notifications on projector
**** audio
=routing_key=audio= messages.

***** DONE mplayer sink                                           :@irq0:
shell one-liner with amqp-tools
**** OPEN uri
=routing_key=uri= messages.

Idea: Play media URIs in messages. Sinilar to the mplayer listener on cube.
**** OPEN user
Get a message to a specific user. Configure means to reach the user
somewhere. Have fallbacks. Like "IRC->Jabber->Email->SMS".
*** Telephony
**** TEST asterisk prove of concept                                   :@irq0:
- Integrate telephony
- Read chat messages
- Add notifications

- (OPEN) SMS -> IRC
**** OPEN integrate SMS
SMS -> IRC
SMS -> TTS

IRC -> SMS?
*** OPEN speech to text
Integrate speech to text engine

** Architecture Changes
*** ASSIGNED list, help messages for 'cmd' exchange                 :@irq0:
Everyone on the cmd exchange should consume list and help messages.

**** Replies
- help :: If "args" = "$0" : Reply with brief usage and supported commands
- list :: Reply with something like "I exist and my name is"

**** Destination

#+BEGIN_SRC clojure
(str/replace (:src msg) #"recv" "send")
#+END_SRC

**** Status
- The newer commands have this build in. Works fine.

*** IDEA state change exchange?
Ohne globalen state müssen state veränderungen irgendwie kommuniziert
werden. Beispiel: user loggt sich ein.

Beispiel:
- user loggt sich ein
- tts begrüssung triggern
- rule engine wertet systemzustand aus


Mögliche Umsetzung
/st/ exchange. User presence manager sendet message mit "userloggedin"
oder so an den exchange.

Ein event->tts consumer generiert tts commands wenn nötig

Die rule engine verändert ihren systemzustand und wertet rules neu aus.
** Janitor Tasks
*** DONE integrate daemon supervisor                                :@irq0:
runit. See =sv/{available, enabled}=
*** ASSIGNED put asterisk container somewhere                       :@irq0:
Running on janelane. Put on some server. Keep sipgate credentials
private.
*** ASSIGNED plan first release

** Project Name
- EDI :: ++
- ESI :: Enhanced Subraum Intelligence?
*** Subtitle?
- The hacker (friendly) space automation?
* Documentation
The core of the architecture is the rabbitmq amqp message server.
Every pice of code connects in some way to it.

Most services share a couple of well defined exchanges. See the
[[Well-defined Exchanges]] for a description.

** Glossary
- source :: Apps that only/mainly produce messages
- sink :: Apps that only/mainly consume messages
- processor :: Apps that transform messages. Consume -> Produce.
- bot :: Consumer/Producer that add external/foreign interfaces to the
         system. Like IRC.

** Well-defined Exchanges
https://git.c3pb.de/c3pb/subraum-automatisierung/blob/master/doc/exchanges.jpeg

*** msg
Raw messages received from somewhere. This should be something that
can be parsed to a command.

Type: topic

**** Routing Keys
In general: protocol.bot-name.{send,recv,presence}.channel

 * irc.EDI.recv.#c3pb.sh
 * irc.EDI.send.#c3pb.sh
 * irc.EDI.presence
**** Messages
***** #.send.*
Content-Type: application/json

- msg :: Message body
- user :: Destination user

Content-Type: text/plain
body: Message
***** #.recv.*
Content-Type: application/json
- msg :: Message body
- user :: Message sender
**** Processors
***** parse-commands.py
Transform =!<command>= to *cmd* Messages. (See *cmd* Exchange)

**** Bots
***** IRC Bot - mqbot.py
IRC -> MQ, MQ -> IRC

**** Sinks

**** Sources

*** cmd
Messages that do something :)

Type: topic

**** Known routing Keys

***** TTS
- tts
- say
- forune
***** Actor Service
- act
***** subinit
- telinit
- runlevel
***** thehonestbookoftruth
- login
- logout
- logout-all
- ul
- eta
- uneta
***** What every command should implement:
- list
- help

**** Messages
Content-Type: application/json

- cmd :: Usually the same as the routing key when parsed from *msg*
         Messages. Could be different. Not sure why I include it. The
         clojure tools use the to dispatch handlers..
- args :: Argument string.
- user :: User that send the command. The command may use this to log.
- src :: Command origin. Replies will be send here with the word
         /recv/ replaced by /send/. If the src is invalid replies will
         just vanish :)
- dst :: Where to put the result. This option is strictly optional.
         Implement a same default like reply based on =src= or default destination.

**** Sources
**** Sinks
**** Processors
***** tts
Transform /tts/ *cmd* Messages to notification audio messages.

Text -> Audio file.

***** Simple Actor Service - act.py
Map /act/ commands to actors.

Example:
venti on => 433Mhz sender, payload 11111 1 1

See =act_433mhz= exchange for the 433Mhz actor implementation.

*** notify
*Sink* exchage for notifications.

**** Routing Keys
- audio
- text

**** Sinks
***** mplayer one-liner
#+BEGIN_SRC sh
amqp-consume --url="amqp://mopp" --exchange="notify" --routing-key="audio" mplayer -
#+END_SRC

**** Messages
Content-Type depending on exchange keys. Should be directly usable by
the sink (e.g mp3 file to hand over to mplayer).

*** =act_433mhz=                                                  :private:
*Sink* exchange to signal 433mhz transmitter.

Type: fanout

**** Messages
Commandline arguments for `rcswitch-pi`.

**** Sinks
*** subinit                                                       :private:
*Sink* exchange for subinit messages

Type: topic
**** Messages
Content-type: text/plain

Must always contain the same as the routing key.
**** Sinks
***** subinit-rc
Launch scripts on subinit messages consumed. Feel similar to sysvinit
scripts and runlevels

** Software, Libs, etc.
*** Debian packages
- rabbitmq-server (debian testing ist aktuell genug)
- python-pika
- python-amqplib
- amqp-tools

*** docker
For development docker seemes a good choice:
#+BEGIN_SRC sh
sudo docker run -p :5672 -p :15672 -v /scratch/docker-data/rabbitmq:/var/lib/rabbitmq/mnesia f04150b0661e
sudo docker build github.com/mikaelhg/docker-rabbitmq.git
#+END_SRC

Note that the exchanges are configured by hand..

Use =mopp=, running on the dell netbook.
*** Useful libraries

** Development
Install requirements. Setup exchanges in rabbitmq. The web interfaces
comes in handy here ;)

*** Repository Organization
- src :: Tools that only *publish* messages
- sink :: Tools that only *consume* messages
- proc :: Tools that *consume* and *publish* with some kind of
          processing going on
- bot :: Adapter to other protocols like IRC. *publisher* and *consumer*
- misc :: Useful stuff for testing, reference, whatever. Configuration
          files for external tools like asterisk
- sv :: Contains =available= and =enabled= directories. When EDI is
        started with the =run= script, start subsystems linked to
        =enabled= directory.
- log :: Log output for =sv/enabled= daemons.

Most larger tools are subtree merged from elsewhere. This repo is kind
of the collected deployment branch.

Have something to add? Let me pull your repo!

*** External Documentation
- [[http://www.rabbitmq.com/getstarted.html][Must read rabbitmq tutorial - covers all the basic use cases]]

*** Libraries
**** Python
- pika :: http://pika.readthedocs.org/en/latest/ Documented, Async lib
- amqplib :: simpler non-threaded library; documentation shipped in
             the .py files. Which are quite readable ;)

**** Commandline
- amqp-tools :: Make sure you get the recent ones. Debian testing
                works quite well. Debian stable not so.

**** Clojure
- langohr :: http://clojurerabbitmq.info/ Excellent library.

#+BEGIN_HTML
<script src="js/jquery.js"></script>
<script src="js/jquery-ui.js"></script>
<script src="js/jquery.tocify.js"></script>
<script src="js/bootstrap.js"></script>
<script src="js/custom.js"></script>
#+END_HTML
