#+TITLE: EDI
#+OPTIONS: creator:nil author:nil H:4 toc:2 num:2
#+SEQ_TODO: OPEN IDEA ASSIGNED TEST | DONE
#+HTML_HEAD: <link href="css/bootstrap.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/bootstrap-responsive.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/jquery.tocify.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/custom.css" rel="stylesheet" media="screen">

* Ideas, Todos
** Features
*** OPEN User Notifications                                            :r1:
- Im LDAP gibt es eine liste mit wegen einen user zu notifien
  - IRC nick
  - jabber id
  - twitter account (@foo)
  - email
- Notifications werden "reliable" zugestellt. Irgendwo kommt die
  notification an
- Message exchange und consumer sagen nack, wenn nicht zustellbar.
  Z.B. IRC offline
- Aehlich wie die notify exchange, audio fuer shouts in den subraum

*** OPEN guess commands                                                :c3po:
- see =thomas.py=, =pr.py= auf cube

- aus normalem text informationen gewinnen
- In etwa "mach mal licht an" -> "cmd bulb on"

*** OPEN hubelmeter                                                    :c3po:
*** OPEN big red button / klotz
- hardware button loest 'bigredbutton' command aus?

- Oder: Es können ja durchaus mehrere dinge einen big red button gebrauchen
- Vielleich ein button exchange einrichten auf dem verschiedene dienste
  lauschen können?
- Mehrere Buttons?
- Prototyp: Button exchange, Button an raspberry pie?

**** Story
Pizza Bestellung endet in 5 minuten. Countdown läuft. Stoppen? Drück
den button irgendwo im Raum. Zahlenkombination eingeben? Button an der
Decke?

  - Bei der Pizza Bestellung angeben? Nur stoppbar durch eingeben von
    31337 auf'm PIN Pad?
    - Pizza daemon wartet auf button 31337 messages..

*** OPEN jabber bot                                                    :r1:
- user same msg exchange as irc bot

- Possible routing keys: "jabber.recv.raw" "jabber.send.raw"

*** OPEN mail bot                                                      :r1:
- wie jabber bot nur ueber email
- nuetzlich auch fuer den notify: user service
- unauthenticated mail?!

*** OPEN irc reader
In simpler implementiert. Siehe [[misc/read_msg.py]]. Keine verschiedenen Stimmen.

**** assign voices to each participant
***** parameters
- speed
- pitch
- voice: lea, julia, kenny...
**** participants can change voices

*** OPEN calendar integration: source                                    :r1:
- Repeadedly parse calendar files. Idealy ics. Load from caldav?
  google calendar?

**** Variants
***** Calendar Commands
- Im Kallender stehen edi commands. Diese zu den eingestellten Zeiten
  injecten.

Quasi alternative zu CRON.

irq0: Damit koennte ich mir meinen Wecker bauen..

***** Events
- Event :: Something is going to happen at a point in time. Wie das
           digitale Zeitalter..

Per TTS, Text notification, IRC, Jabber whatever hinweisen
*** OPEN calendar integration: sink/proc
- siehe auch [[(conj 'seri hackerfyhstuck)]]
- daily events im irc topic
- events auf wallhack anzeigen
- notification mails?
  - hackerfryhstyck automatisch ankuendigen
- kallender abonierbar
- [[(conj 'seri hackerfyhstuck)]] traegt leute zum event ein
- ETAs als calendar events
*** OPEN graphite integration
Es macht sinn sensoren an ein graphite zu knoten. Dadruch bekommt man
gleich daten über zeit und eine ganze reihe von funktionen über diese
daten.

Daten aus graphite gekommt man über die =?render= HTTP Schnittstelle
in den gängigsten formaten wie JSON, CSV, SVG, PNG.

**** Mögliche Umsetzungen
***** RPC
AMQP RPC Pattern implementieren
***** PubSub
Subscribe periodic sensor updates
***** Nicht integrieren
Direkt mit Graphite sprechen
*** OPEN Wetterbericht
Wie ist das subraum wetter?

Als email abbonierbar? Erreichbar per Telefon

Content:
- Temperatur innen. (Mit forecast?)
- Temperatur aussen
- User liste
- Termine heute:
  - Heute abend ist smalltalk
  - 15:00-18:00 Safer Internet Day in der ComBi
- Kommentar wie "Ganz schön sonnig heute. Komm lieber in den Subraum"
*** OPEN thehonestbookoftruth: support !eta with dates
Support:
- !eta 2014-03-12 20:00
- !eta Tomorrow 20:00
- !eta Morgen 20:00
- !eta Mittwoch 20:00

Retain support for times only. Use today as date
- !eta 20:00
*** OPEN set irc topics
- Calendar events like smalltalks
- something like the emacs modeline?
*** OPEN dhcp lease loest login aus                                  :c3pb:
*** OPEN Würfel
- Zufällig einen user im irc bestimmen für $aufgabe?
*** OPEN Begrüssungen
- Vorher: events
- Verändern durch git repo
*** OPEN Soundboard
!sob ?

git repo mit soundfiles

!sob <file>

file matched files im repo

antwortet mit ID3tags was ist
*** OPEN (conj 'seri hackerfyhstuck)
leute zu dingen eintragen per bot
*** ASSIGNED pizza / essen / f00d                               :@hej:c3po:
*** ASSIGNED actor service / rule engine                              :@irq0:

currently a simple python script to map things like 'act bulb on' to
messages on the =act_433_mhz= queue

Idealy something with a rule engine:
- First user logged in: initiate startup sequence.
- Last user log out initiate


In the basic incarnation:
Map 'act' messages to actors. /act/ messages are something a user
can grasp, e.g /act venti on/. actors are something specific having
their own actor exchanges, e.g /act_433_mhz/ where messages contain
the commands for the sender as payload.
**** Idee
- Jedes event transformiert den aktuellen system state in einen neuen
  (clojure swap! semantik)
- Ändern des systemstates stösst die rule engine an
- Regeln verändern den state nicht (direkt). Können aber events
  emiten.
- State änderungen sind atomar. Ein event verändert. Andere events
  warten die änderungen ab. Änderungen sind ganz oder garnicht.
- Rule engine ausführungen immer auf neuen state. Rule engine
  ausführungen sind unabhängig voneinander
- Was ist mit aktoren?
  - State änderung muss irgendwie auch aktoren triggern können..
  - Hm.
  - State change funktionen für bestimmte events?
    - führen auch aktionen aus?

  - should-be relation:
    - event sagt "an", state sagt "aus" -> an aktion generieren
    - event sagt "an", state sagt "an" -> nop

      #+BEGIN_EXAMPLE
EVENT -> OLD STATE -> STATE CHANGE -> NEW STATE
                       -> ACTIONS

EVENT -> OLD STATE -> STATE CHANGE -> NEW STATE
                                   -> DIFFERENCE OLD NEW
                                   -> ACTIONS

      #+END_EXAMPLE
- Fakten, konfiguration
  - aktor name zu triggernes foo
  - 'act bulb on' -> msg =11111 1 on= an =act_433mhz= exchange.

- =(state-change old)=

*** ASSIGNED openhab integration                                  :@snowball:
*** ASSIGNED music player daemon sink                     :@snowball:c3po:r1:
- mpd commands als messages
- Story: Ein EDI MQ command kann verschiedene music player daemons steuern
- Probleme
  - Mehrere mpds unterstützen; gleichzeitig steuern?
*** ASSIGNED parse-commands: parse commands only from users having op uflag :@irq0:r1:
*** TEST presence: eta login                                     :@irq0:r1:
Commands: !ul, !eta, !login, !logout

- cmd exchange consumer/producer
- store login, eta state somewhere

Implemented: [[proc/thehonestbookoftruth]]
*** TEST dmx actor                                     :@grollicus:c3po:r1:
See: =sink/dmx=. Written in ruby.
*** DONE scheduled messages                                      :@irq0:r1:
- hourly audio messages
- web gui?
- clojure + quarz scheduler?

Implementation: [[src/shouts]]
cronjob + amqp-tools + mp3 files

mp3 files found on cube..
*** DONE shutdown/startup                                        :@irq0:r1:
Veralgemeinert implementiert: Init mit runlevels.

Reagiert auf Commands:
- telinit ::  Runlevel ändern
- runlevel :: Aktuelles runlevel zurückgeben


Emitiert Messages auf in der =subinit= Exchange.
Format: =rc.RUNLEVEL.ACTION=


Runleveländerungen (z.B 0 -> 4) generieren Events: 1 start, 2 start, 3
start, 4 start.

Runlevels sind dazu gedacht, um den Subraum auch nur "halb"
anzuschalten zu können. Beispielsweise ohne Mamestation.

**** Tool: subinit-rc
Tool um für subinit Messages Scripts zu starten. Aufgebaut wie rc*.d
runlevel scripts.

Skripts werden mit run-parts gestartet und bekommen die ACTION als
ersten Parameter

*** DONE text to speech command                                  :@irq0:r1:
- listen for tts, say, fortune commands
- text to speech messages
- put mp3 files in notify exchange with key audio

Actually two implementations. One pico2wave in the EDI repo and one
based on the old acapella-group web scripting.
*** DONE irc bot                                                 :r1:@irq0:
- IRC receive -> msg exchange with key irc.recv.raw
- msg exchange with key irc.send.raw -> IRC send
*** DONE 433MHz actor                                            :r1:@irq0:
=act_433mhz= exchange

- consumer on raspberrypi
- message payload = commandline arguments to rcswitch tool

*** DONE ircbot: Add op flag for ops in #c3pb.sh                 :@irq0:r1:
Ursprünglich: Bot antwortet nur auf OPs.

Bot fügt jetzt ein flag "op" in msg.uflags ein, wenn user op rechte in
seinem channel hat.

Dieses flag kann dann von msg consumern ausgewertet werden.
*** Notify sink                                                        :r1:
**** text
=routing_key=text= messages.

***** DONE libnotify sink                                         :@irq0:
***** OPEN text notifications on projector
**** audio
=routing_key=audio= messages.

***** DONE mplayer sink                                           :@irq0:
shell one-liner with amqp-tools
**** OPEN uri
=routing_key=uri= messages.

Idea: Play media URIs in messages. Sinilar to the mplayer listener on cube.
*** Telephony
**** TEST asterisk prove of concept                             :@irq0:r1:
- Integrate telephony
- Read chat messages
- Add notifications

- (OPEN) SMS -> IRC
**** OPEN integrate SMS
SMS -> IRC
SMS -> TTS

IRC -> SMS?
**** OPEN Wetterbericht
Gesprochener Wetterbericht. Siehe oben
*** OPEN speech to text
Integrate speech to text engine

** Architecture Changes
*** ASSIGNED list, help messages for 'cmd' exchange              :@irq0:r1:
Everyone on the cmd exchange should consume list and help messages.

**** Replies
- help :: If "args" = "$0" : Reply with brief usage and supported commands
- list :: Reply with something like "I exist and my name is"

**** Destination

#+BEGIN_SRC clojure
(str/replace (:src msg) #"recv" "send")
#+END_SRC

**** Status
- The newer commands have this build in. Works fine.

*** IDEA state change exchange?
Ohne globalen state müssen state veränderungen irgendwie kommuniziert
werden. Beispiel: user loggt sich ein.

Beispiel:
- user loggt sich ein
- tts begrüssung triggern
- rule engine wertet systemzustand aus


Mögliche Umsetzung
/st/ exchange. User presence manager sendet message mit "userloggedin"
oder so an den exchange.

Ein event->tts consumer generiert tts commands wenn nötig

Die rule engine verändert ihren systemzustand und wertet rules neu aus.
** Janitor Tasks
*** DONE integrate daemon supervisor                                :@irq0:
runit. See =sv/{available, enabled}=
*** ASSIGNED put asterisk container somewhere                       :@irq0:
Running on janelane. Put on some server. Keep sipgate credentials
private.
*** ASSIGNED plan first release
*** OPEN All EDI subsystems use environment variables to configure..   :r1:
Alle Subsysteme müssen für generelle Einstellungen Environment
Variablen benutzen. Ist die Variable nicht gesetzt muss ein sinnvoller
default Wert verwendet werden.

Warum? Env Variablen vererben sich zu Kindprozessen. Der Service
Supervisor setzt also Globale Variablen und die einzelnen Subsysteme
bekommen die Einstellungen mit. Siehe =conf/GLOBALS= und =run=.

Variablen:
- =AMQP_SERVER=

Für die Service Skripte:
- =APPDIR=
- =LOGDIR=

** Project Name
- EDI :: ++
- ESI :: Enhanced Subraum Intelligence?
*** Subtitle?
- The hacker (friendly) space automation?
* Documentation
The core of the architecture is the rabbitmq amqp message server.
Every pice of code connects in some way to it.

Most services share a couple of well defined exchanges. See the
[[Well-defined Exchanges]] for a description.

** Setup
In theory(tm). Expect some settings to still be hard coded somewhere.

1. Install AMQP Server. Best use RabbitMQ
2. git clone this repo
3. Create symlinks from =sv/available= to =sv/enabled= for the desired
   subsystems to run
3. ...
4. Start EDI with =run=

** Glossary
- source :: Apps that only/mainly produce messages
- sink :: Apps that only/mainly consume messages
- processor :: Apps that transform messages. Consume -> Produce.
- bot :: Consumer/Producer that add external/foreign interfaces to the
         system. Like IRC.

** Well-defined Exchanges
https://git.c3pb.de/c3pb/subraum-automatisierung/blob/master/doc/exchanges.jpeg

*** msg
Raw messages received from somewhere. This should be something that
can be parsed to a command.

Type: topic

**** Routing Keys
In general: protocol.bot-name.{send,recv,presence}.channel

 * irc.EDI.recv.#c3pb.sh
 * irc.EDI.send.#c3pb.sh
 * irc.EDI.presence
**** Messages
***** #.send.*
Content-Type: application/json

- msg :: Message body
- user :: Destination user

Content-Type: text/plain
body: Message
***** #.recv.*
Content-Type: application/json
- msg :: Message body
- user :: Message sender
**** Processors
***** parse-commands.py
Transform =!<command>= to *cmd* Messages. (See *cmd* Exchange)

**** Bots
***** IRC Bot - mqbot.py
IRC -> MQ, MQ -> IRC

**** Sinks

**** Sources

*** cmd
Messages that do something :)

Type: topic

**** Known routing Keys

***** TTS
- tts
- say
- forune
***** Actor Service
- act
***** subinit
- telinit
- runlevel
***** thehonestbookoftruth
- login
- logout
- logout-all
- ul
- eta
- uneta
***** What every command should implement:
- list
- help

**** Messages
Content-Type: application/json

- cmd :: Usually the same as the routing key when parsed from *msg*
         Messages. Could be different. Not sure why I include it. The
         clojure tools use the to dispatch handlers..
- args :: Argument string.
- user :: User that send the command. The command may use this to log.
- src :: Command origin. Replies will be send here with the word
         /recv/ replaced by /send/. If the src is invalid replies will
         just vanish :)
- dst :: Where to put the result. This option is strictly optional.
         Implement a same default like reply based on =src= or default destination.

**** Sources
**** Sinks
**** Processors
***** tts
Transform /tts/ *cmd* Messages to notification audio messages.

Text -> Audio file.

***** Simple Actor Service - act.py
Map /act/ commands to actors.

Example:
venti on => 433Mhz sender, payload 11111 1 1

See =act_433mhz= exchange for the 433Mhz actor implementation.

*** notify
*Sink* exchage for notifications.

**** Routing Keys
- audio
- text

**** Sinks
***** mplayer one-liner
#+BEGIN_SRC sh
amqp-consume --url="amqp://mopp" --exchange="notify" --routing-key="audio" mplayer -
#+END_SRC

**** Messages
Content-Type depending on exchange keys. Should be directly usable by
the sink (e.g mp3 file to hand over to mplayer).

*** =act_433mhz=                                                  :private:
*Sink* exchange to signal 433mhz transmitter.

Type: fanout

**** Messages
Commandline arguments for `rcswitch-pi`.

**** Sinks
*** subinit                                                       :private:
*Sink* exchange for subinit messages

Type: topic
**** Messages
Content-type: text/plain

Must always contain the same as the routing key.
**** Sinks
***** subinit-rc
Launch scripts on subinit messages consumed. Feel similar to sysvinit
scripts and runlevels

** Software, Libs, etc.
*** Debian packages
- rabbitmq-server (debian testing ist aktuell genug)
- python-pika
- python-amqplib
- amqp-tools

*** docker
For development docker seemes a good choice:
#+BEGIN_SRC sh
sudo docker run -p :5672 -p :15672 -v /scratch/docker-data/rabbitmq:/var/lib/rabbitmq/mnesia f04150b0661e
sudo docker build github.com/mikaelhg/docker-rabbitmq.git
#+END_SRC

Note that the exchanges are configured by hand..

Use =mopp=, running on the dell netbook.
*** Useful libraries

** Development
Install requirements. Setup exchanges in rabbitmq. The web interfaces
comes in handy here ;)

*** Repository Organization
- src :: Tools that only *publish* messages
- sink :: Tools that only *consume* messages
- proc :: Tools that *consume* and *publish* with some kind of
          processing going on
- bot :: Adapter to other protocols like IRC. *publisher* and *consumer*
- misc :: Useful stuff for testing, reference, whatever. Configuration
          files for external tools like asterisk
- sv :: Contains =available= and =enabled= directories. When EDI is
        started with the =run= script, start subsystems linked to
        =enabled= directory.
- log :: Log output for =sv/enabled= daemons.

Most larger tools are subtree merged from elsewhere. This repo is kind
of the collected deployment branch.

Have something to add? Let me pull your repo!

*** External Documentation
- [[http://www.rabbitmq.com/getstarted.html][Must read rabbitmq tutorial - covers all the basic use cases]]

*** Libraries
**** Python
- pika :: http://pika.readthedocs.org/en/latest/ Documented, Async lib
- amqplib :: simpler non-threaded library; documentation shipped in
             the .py files. Which are quite readable ;)

**** Commandline
- amqp-tools :: Make sure you get the recent ones. Debian testing
                works quite well. Debian stable not so.

**** Clojure

- langohr :: http://clojurerabbitmq.info/ Excellent library.

#+BEGIN_HTML
<script src="js/jquery.js"></script>
<script src="js/jquery-ui.js"></script>
<script src="js/jquery.tocify.js"></script>
<script src="js/bootstrap.js"></script>
<script src="js/custom.js"></script>
#+END_HTML
