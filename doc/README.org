#+TITLE: EDI
#+OPTIONS: creator:nil author:nil H:4 toc:2 num:2
#+SEQ_TODO: OPEN IDEA ASSIGNED TEST | DONE
#+HTML_HEAD: <link href="css/bootstrap.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/bootstrap-responsive.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/jquery.tocify.css" rel="stylesheet">
#+HTML_HEAD: <link href="css/custom.css" rel="stylesheet" media="screen">

* Ideas, Todos
** Features
*** OPEN hubelmeter                                                    :c3po:
*** OPEN jabber bot
- user same msg exchange as irc bot

- Possible routing keys: "jabber.recv.raw" "jabber.send.raw"

*** OPEN mail bot
- wie jabber bot nur ueber email
- nuetzlich auch fuer den notify: user service
- unauthenticated mail?!

*** OPEN calendar integration: source
- Repeadedly parse calendar files. Idealy ics. Load from caldav?
  google calendar?

**** Variants
***** Calendar Commands
- Im Kallender stehen edi commands. Diese zu den eingestellten Zeiten
  injecten.

Quasi alternative zu CRON.

irq0: Damit koennte ich mir meinen Wecker bauen..

***** Events
- Event :: Something is going to happen at a point in time. Wie das
           digitale Zeitalter..

Per TTS, Text notification, IRC, Jabber whatever hinweisen
*** OPEN calendar integration: sink/proc
- siehe auch [[(conj 'seri hackerfyhstuck)]]
- daily events im irc topic
- events auf wallhack anzeigen
- notification mails?
  - hackerfryhstyck automatisch ankuendigen
- kallender abonierbar
- [[(conj 'seri hackerfyhstuck)]] traegt leute zum event ein
- ETAs als calendar events
*** OPEN graphite integration
Es macht sinn sensoren an ein graphite zu knoten. Dadruch bekommt man
gleich daten über zeit und eine ganze reihe von funktionen über diese
daten.

Daten aus graphite gekommt man über die =?render= HTTP Schnittstelle
in den gängigsten formaten wie JSON, CSV, SVG, PNG.

**** Mögliche Umsetzungen
***** RPC
AMQP RPC Pattern implementieren
***** PubSub
Subscribe periodic sensor updates
***** Nicht integrieren
Direkt mit Graphite sprechen
*** OPEN thehonestbookoftruth: support !eta with dates
Support:
- !eta 2014-03-12 20:00
- !eta Tomorrow 20:00
- !eta Morgen 20:00
- !eta Mittwoch 20:00

Retain support for times only. Use today as date
- !eta 20:00
*** OPEN set irc topics/modeline
- Calendar events like smalltalks
- something like the emacs modeline?
*** OPEN Begrüssungen
- Vorher: events
- Verändern durch git repo
- /Hallo irq0. Wilkommen im Subraum/
*** OPEN dhcp lease loest login aus                                  :c3pb:
- private exchange fuer dhcp messages
  - vom router aus eintueten
- tool um mac adressen usern zuzuweisen
- tool um diese user einzuloggen
*** OPEN voice recognition
**** Idea
To speech to text. At least in english. Perform natural language
processing to extract meaning. Generate commands.

**** Tools
***** pocketsphinx
pocketsphinx is a cpp implementation of sphinx, smaller and not java.

- debian/ubuntu packages: https://launchpad.net/~dhuggins/+archive/cmusphinx
- transformations:
  - we can't recognize users by voice.
  - "!say" not nice to say. instead:
    - "user command <user> <command>"
    - "UC <user> <command>"
    - "command <command>
    - "do <command>"

- "EDI: command say foo"
- "EDI: user command seri login"
- "EDI: user command seri logout"
- "EDI <TONE> "

***** wit.io
- natural language processing web app
- does the text -> meaning part
- exports sphinx language models

**** integration
***** msg
- recv :: voice recognition with some custom transformations
- send :: notify.audio?
***** asterisk
- .. we can recocnize users by callerid
- login by phone?
- desktop edi voice clients based on SIP

*** ASSIGNED pizza / essen / f00d                               :@hej:c3po:
*** DONE irc reader                                                   :@irq0:
In simpler implementiert. Siehe [[misc/read_msg.py]]. Keine verschiedenen Stimmen.
**** assign voices to each participant
***** parameters
- speed
- pitch
- voice: lea, julia, kenny...
**** participants can change voices
** Architecture Changes
*** ASSIGNED list, help messages for 'cmd' exchange              :@irq0:r1:
Everyone on the cmd exchange should consume list and help messages.

**** Replies
- help :: If "args" = "$0" : Reply with brief usage and supported commands
- list :: Reply with something like "I exist and my name is"

**** Destination

#+BEGIN_SRC clojure
(str/replace (:src msg) #"recv" "send")
#+END_SRC

**** Status
- The newer commands have this build in. Works fine.

*** IDEA state change exchange / log / events
Ohne globalen state müssen state veränderungen irgendwie kommuniziert
werden. Beispiel: user loggt sich ein.

Beispiel:
- user loggt sich ein
- tts begrüssung triggern
- rule engine wertet systemzustand aus


Mögliche Umsetzung
/st/ exchange. User presence manager sendet message mit "userloggedin"
oder so an den exchange.

Ein event->tts consumer generiert tts commands wenn nötig

Die rule engine verändert ihren systemzustand und wertet rules neu aus.
**** Implementation
loev exchange: Log and events. Siehe papier.
** Janitor Tasks
*** DONE integrate daemon supervisor                                :@irq0:
runit. See =sv/{available, enabled}=
*** ASSIGNED put asterisk container somewhere                       :@irq0:
Running on janelane. Put on some server. Keep sipgate credentials
private.
*** ASSIGNED plan first release
** Release 1

*** DONE Soundboard                                                 :@irq0:
!sob ?

git repo mit soundfiles

!sob <file>

file matched files im repo

antwortet mit ID3tags was ist
*** DONE Wetterbericht
Wie ist das subraum wetter?

Als email abbonierbar? Erreichbar per Telefon

Content:
- Temperatur innen. (Mit forecast?)
- Temperatur aussen

*** DONE parse-commands: parse commands only from users having op uflag :@irq0:r1:
*** DONE presence: eta login                                     :@irq0:r1:
Commands: !ul, !eta, !login, !logout

- cmd exchange consumer/producer
- store login, eta state somewhere

Implemented: [[proc/thehonestbookoftruth]]
*** DONE music player daemon sink                             :@irq0:r1:c3po:
- mpd commands als messages
- Story: Ein EDI MQ command kann verschiedene music player daemons steuern
- Probleme
  - Mehrere mpds unterstützen; gleichzeitig steuern?
**** Implementation
- shell wrapper around mpc
- send notifications after play
- support some extra commands to load playlists from remote sources

*** DONE dmx actor                                       :@grollicus:c3po:r1:
See: =sink/dmx=. Written in ruby.
*** DONE scheduled messages                                      :@irq0:r1:
- hourly audio messages
- web gui?
- clojure + quarz scheduler?

Implementation: [[src/shouts]]
cronjob + amqp-tools + mp3 files

mp3 files found on cube..
*** DONE shutdown/startup                                        :@irq0:r1:
Veralgemeinert implementiert: Init mit runlevels.

Reagiert auf Commands:
- telinit ::  Runlevel ändern
- runlevel :: Aktuelles runlevel zurückgeben


Emitiert Messages auf in der =subinit= Exchange.
Format: =rc.RUNLEVEL.ACTION=


Runleveländerungen (z.B 0 -> 4) generieren Events: 1 start, 2 start, 3
start, 4 start.

Runlevels sind dazu gedacht, um den Subraum auch nur "halb"
anzuschalten zu können. Beispielsweise ohne Mamestation.

**** Tool: subinit-rc
Tool um für subinit Messages Scripts zu starten. Aufgebaut wie rc*.d
runlevel scripts.

Skripts werden mit run-parts gestartet und bekommen die ACTION als
ersten Parameter

*** DONE text to speech command                                  :@irq0:r1:
- listen for tts, say, fortune commands
- text to speech messages
- put mp3 files in notify exchange with key audio

Actually two implementations. One pico2wave in the EDI repo and one
based on the old acapella-group web scripting.
*** DONE irc bot                                                 :r1:@irq0:
- IRC receive -> msg exchange with key irc.recv.raw
- msg exchange with key irc.send.raw -> IRC send
*** DONE 433MHz actor                                            :r1:@irq0:
=act_433mhz= exchange

- consumer on raspberrypi
- message payload = commandline arguments to rcswitch tool

*** DONE ircbot: Add op flag for ops in #c3pb.sh                 :@irq0:r1:
Ursprünglich: Bot antwortet nur auf OPs.

Bot fügt jetzt ein flag "op" in msg.uflags ein, wenn user op rechte in
seinem channel hat.

Dieses flag kann dann von msg consumern ausgewertet werden.
*** Notify sink                                                        :r1:
**** text
=routing_key=text= messages.

***** DONE libnotify sink                                         :@irq0:
***** OPEN text notifications on projector
**** audio
=routing_key=audio= messages.

***** DONE mplayer sink                                           :@irq0:
shell one-liner with amqp-tools
**** OPEN uri
=routing_key=uri= messages.

Idea: Play media URIs in messages. Sinilar to the mplayer listener on cube.
*** Telephony
**** TEST asterisk prove of concept                             :@irq0:r1:
- Integrate telephony
- Read chat messages
- Add notifications

- (OPEN) SMS -> IRC
**** OPEN integrate SMS
SMS -> IRC
SMS -> TTS

IRC -> SMS?
**** OPEN Wetterbericht
Gesprochener Wetterbericht. Siehe oben
*** OPEN edi python library
- reduce code duplication accross most of the tools
- start with =listen_commands= tool

#+BEGIN_SRC python

  @edi_cmd("say")
  def tts(chan, command):


  @edi_cmd("help")
  def help(chan, command):
      edi.emit_reply(chan, command["src"], "USAGE: say <message>")


  @edi_msg_recv_all()
  def all(frm, msg):
      edi.msg.reply

  @edi_msg_recv_regex("edi ist doof", key="irc.#")
  def foo(frm, msg):
      edi.msg.reply(frm, "fuck you")



  def main():
      edi.register_command(tts_callback, "tts")

      edi.recv_msg(callback, "irc.#")
      edi.emit_msg("irc.send.EDI")
      edi.cmd.say("fooo")
      edi.msg.send(to, "msg")

      edi.register_recv_message(callback, "irc.#")



#+END_SRC


#+BEGIN_SRC python


  class EdiComand(edi.command):
      def cmd_help(**args):
          return "foo"
      def cmd_say(cmd, args, src, dst="audio"):
          err = edi.emit_notification(tts.tts(args), dst)
          if err:
              return "TTS erro", err




#+END_SRC


*** OPEN listen commands doesn't ack messages                         :bug:
*** OPEN subraum start stop knoeppkens
- python implementierung nicht sehr robust. in c implementieren?
*** OPEN Add generic help command
- "base commands command"
- help
*** OPEN parse commands: Add error message for unauthorized users
*** OPEN edi auf cube umziehen
*** OPEN All EDI subsystems use environment variables to configure..   :r1:
Alle Subsysteme müssen für generelle Einstellungen Environment
Variablen benutzen. Ist die Variable nicht gesetzt muss ein sinnvoller
default Wert verwendet werden.

Warum? Env Variablen vererben sich zu Kindprozessen. Der Service
Supervisor setzt also Globale Variablen und die einzelnen Subsysteme
bekommen die Einstellungen mit. Siehe =conf/GLOBALS= und =run=.

Variablen:
- =AMQP_SERVER=

Für die Service Skripte:
- =APPDIR=
- =LOGDIR=

* Documentation
The core of the architecture is the rabbitmq amqp message server.
Every pice of code connects in some way to it.

Most services share a couple of well defined exchanges. See the
[[Well-defined Exchanges]] for a description.

** Setup
In theory(tm). Expect some settings to still be hard coded somewhere.

1. Install AMQP Server. Best use RabbitMQ
2. git clone this repo
3. Create symlinks from =sv/available= to =sv/enabled= for the desired
   subsystems to run
3. ...
4. Start EDI with =run=

** Glossary
- source :: Apps that only/mainly produce messages
- sink :: Apps that only/mainly consume messages
- processor :: Apps that transform messages. Consume -> Produce.
- bot :: Consumer/Producer that add external/foreign interfaces to the
         system. Like IRC.

** Well-defined Exchanges
https://git.c3pb.de/c3pb/subraum-automatisierung/blob/master/doc/exchanges.jpeg

*** msg
Raw messages received from somewhere. This should be something that
can be parsed to a command.

Type: topic

**** Routing Keys
In general: protocol.bot-name.{send,recv,presence}.channel

 * irc.EDI.recv.#c3pb.sh
 * irc.EDI.send.#c3pb.sh
 * irc.EDI.presence
**** Messages
***** #.send.*
Content-Type: application/json

- msg :: Message body
- user :: Destination user

Content-Type: text/plain
body: Message
***** #.recv.*
Content-Type: application/json
- msg :: Message body
- user :: Message sender
**** Processors
***** parse-commands.py
Transform =!<command>= to *cmd* Messages. (See *cmd* Exchange)

**** Bots
***** IRC Bot - mqbot.py
IRC -> MQ, MQ -> IRC

**** Sinks

**** Sources

*** cmd
Messages that do something :)

Type: topic

**** Known routing Keys

***** TTS
- tts
- say
- forune
***** Actor Service
- act
***** subinit
- telinit
- runlevel
***** thehonestbookoftruth
- login
- logout
- logout-all
- ul
- eta
- uneta
***** What every command should implement:
- list
- help

**** Messages
Content-Type: application/json

- cmd :: Usually the same as the routing key when parsed from *msg*
         Messages. Could be different. Not sure why I include it. The
         clojure tools use the to dispatch handlers..
- args :: Argument string.
- user :: User that send the command. The command may use this to log.
- src :: Command origin. Replies will be send here with the word
         /recv/ replaced by /send/. If the src is invalid replies will
         just vanish :)
- dst :: Where to put the result. This option is strictly optional.
         Implement a same default like reply based on =src= or default destination.

**** Sources
**** Sinks
**** Processors
***** tts
Transform /tts/ *cmd* Messages to notification audio messages.

Text -> Audio file.

***** Simple Actor Service - act.py
Map /act/ commands to actors.

Example:
venti on => 433Mhz sender, payload 11111 1 1

See =act_433mhz= exchange for the 433Mhz actor implementation.

*** notify
*Sink* exchage for notifications.

**** Routing Keys
- audio
- text

**** Sinks
***** mplayer one-liner
#+BEGIN_SRC sh
amqp-consume --url="amqp://mopp" --exchange="notify" --routing-key="audio" mplayer -
#+END_SRC

**** Messages
Content-Type depending on exchange keys. Should be directly usable by
the sink (e.g mp3 file to hand over to mplayer).

*** =act_433mhz=                                                  :private:
*Sink* exchange to signal 433mhz transmitter.

Type: fanout

**** Messages
Commandline arguments for `rcswitch-pi`.

**** Sinks
*** subinit                                                       :private:
*Sink* exchange for subinit messages

Type: topic
**** Messages
Content-type: text/plain

Must always contain the same as the routing key.
**** Sinks
***** subinit-rc
Launch scripts on subinit messages consumed. Feel similar to sysvinit
scripts and runlevels

** Software, Libs, etc.
*** Debian packages
- rabbitmq-server (debian testing ist aktuell genug)
- python-pika
- python-amqplib
- amqp-tools

*** docker
For development docker seemes a good choice:
#+BEGIN_SRC sh
sudo docker run -p :5672 -p :15672 -v /scratch/docker-data/rabbitmq:/var/lib/rabbitmq/mnesia f04150b0661e
sudo docker build github.com/mikaelhg/docker-rabbitmq.git
#+END_SRC

Note that the exchanges are configured by hand..

Use =mopp=, running on the dell netbook.
*** Useful libraries

** Development
Install requirements. Setup exchanges in rabbitmq. The web interfaces
comes in handy here ;)

*** Repository Organization
- src :: Tools that only *publish* messages
- sink :: Tools that only *consume* messages
- proc :: Tools that *consume* and *publish* with some kind of
          processing going on
- bot :: Adapter to other protocols like IRC. *publisher* and *consumer*
- misc :: Useful stuff for testing, reference, whatever. Configuration
          files for external tools like asterisk
- sv :: Contains =available= and =enabled= directories. When EDI is
        started with the =run= script, start subsystems linked to
        =enabled= directory.
- log :: Log output for =sv/enabled= daemons.

Most larger tools are subtree merged from elsewhere. This repo is kind
of the collected deployment branch.

Have something to add? Let me pull your repo!

*** External Documentation
- [[http://www.rabbitmq.com/getstarted.html][Must read rabbitmq tutorial - covers all the basic use cases]]

*** Libraries
**** Python
- pika :: http://pika.readthedocs.org/en/latest/ Documented, Async lib
- amqplib :: simpler non-threaded library; documentation shipped in
             the .py files. Which are quite readable ;)

**** Commandline
- amqp-tools :: Make sure you get the recent ones. Debian testing
                works quite well. Debian stable not so.

**** Clojure

- langohr :: http://clojurerabbitmq.info/ Excellent library.

#+BEGIN_HTML
<script src="js/jquery.js"></script>
<script src="js/jquery-ui.js"></script>
<script src="js/jquery.tocify.js"></script>
<script src="js/bootstrap.js"></script>
<script src="js/custom.js"></script>
#+END_HTML
n
