#+SEQ_TODO: OPEN IDEA ASSIGNED TEST | DONE

* Ideas, Todos
** Features
*** OPEN User Notifications
- Im LDAP gibt es eine liste mit wegen einen user zu notifien
  - IRC nick
  - jabber id
  - twitter account (@foo)
  - email
- Notifications werden "reliable" zugestellt. Irgendwo kommt die
  notification an
- Message exchange und consumer sagen nack, wenn nicht zustellbar.
  Z.B. IRC offline
- Aehlich wie die notify exchange, audio fuer shouts in den subraum
-
*** ASSIGNED pizza / essen / f00d                               :@hej:c3po:
*** DONE scheduled messages                                         :@irq0:
- hourly audio messages
- web gui?
- clojure + quarz scheduler?

Implementation: [[src/shouts]]
cronjob + amqp-tools + mp3 files

mp3 files found on cube..
*** TEST presence: eta login                                        :@irq0:
Commands: !ul, !eta, !login, !logout

- cmd exchange consumer/producer
- store login, eta state somewhere

Implemented: [[proc/thehonestbookoftruth]]

*** OPEN guess commands                                                :c3po:
- see =thomas.py=, =pr.py= auf cube

- aus normalem text informationen gewinnen
- In etwa "mach mal licht an" -> "cmd bulb on"

*** OPEN hubelmeter                                                    :c3po:
*** DONE shutdown/startup                                           :@irq0:
Veralgemeinert implementiert: Init mit runlevels.

Reagiert auf Commands:
- telinit ::  Runlevel ändern
- runlevel :: Aktuelles runlevel zurückgeben


Emitiert Messages auf in der =subinit= Exchange.
Format: =rc.RUNLEVEL.ACTION=


Runleveländerungen (z.B 0 -> 4) generieren Events: 1 start, 2 start, 3
start, 4 start.

Runlevels sind dazu gedacht, um den Subraum auch nur "halb"
anzuschalten zu können. Beispielsweise ohne Mamestation.

**** Tool: subinit-rc
Tool um für subinit Messages Scripts zu starten. Aufgebaut wie rc*.d
runlevel scripts.

Skripts werden mit run-parts gestartet und bekommen die ACTION als
ersten Parameter

*** OPEN subraum init/shutdown auf subinitd migrieren
*** user authentication
- irc nick <-> subraum LDAP?
- ueberhaupt noetig?
**** ASSIGNED irc bot antwortet nur auf op                         :@irq0:
- bot: only answer to users having op? (TODO)
*** OPEN big red button
- hardware button loest 'bigredbutton' command aus?

- Oder: Es können ja durchaus mehrere dinge einen big red button gebrauchen
p
- Vielleich ein button exchange einrichten auf dem verschiedene dienste
  lauschen können?
- Mehrere Buttons?
- Prototyp: Button exchange, Button an raspberry pie?

**** Story
Pizza Bestellung endet in 5 minuten. Countdown läuft. Stoppen? Drück
den button irgendwo im Raum. Zahlenkombination eingeben? Button an der
Decke?

  - Bei der Pizza Bestellung angeben? Nur stoppbar durch eingeben von
    31337 auf'm PIN Pad?
    - Pizza daemon wartet auf button 31337 messages..


*** DONE text to speech command                                     :@irq0:
- listen for tts, say, fortune commands
- text to speech messages
- put mp3 files in notify exchange with key audio

Actually two implementations. One pico2wave in the EDI repo and one
based on the old acapella-group web scripting.
*** DONE irc bot                                                    :@irq0:
- IRC receive -> msg exchange with key irc.recv.raw
- msg exchange with key irc.send.raw -> IRC send
*** Notify sink

**** text
=routing_key=text= messages.

***** DONE libnotify sink                                         :@irq0:
***** OPEN text notifications on projector
**** audio
=routing_key=audio= messages.

***** DONE mplayer sink                                           :@irq0:
shell one-liner with amqp-tools
**** OPEN uri
=routing_key=uri= messages.

Idea: Play media URIs in messages. Sinilar to the mplayer listener on cube.
*** DONE 433MHz actor                                               :@irq0:
=act_433mhz= exchange

- consumer on raspberrypi
- message payload = commandline arguments to rcswitch tool

*** OPEN jabber bot
- user same msg exchange as irc bot

- Possible routing keys: "jabber.recv.raw" "jabber.send.raw"

*** OPEN mail bot
- wie jabber bot nur ueber email
- nuetzlich auch fuer den notify: user service
- unauthenticated mail?!

*** OPEN dmx actor                                                     :c3po:
See =cube:/var/git/c3po/dmx=. DMX is connected to the serial port.

Example code:
#+BEGIN_EXAMPLE
[2014-02-06 13:45:04] less dmx-disable.py

 #!/usr/bin/python

 import sys
 import serial

 ser = serial.Serial('/dev/dmx', 38400, timeout=1)

 ser.write("B1")

 ser.close()
#+END_EXAMPLE

There is also a dmx jsonrpc server:
=cube:/var/git/c3po/jsonrpcdmx=

*** ASSIGNED actor service / rule engine                              :@irq0:

currently a simple python script to map things like 'act bulb on' to
messages on the =act_433_mhz= queue

Idealy something with a rule engine:
- First user logged in: initiate startup sequence.
- Last user log out initiate


In the basic incarnation:
Map 'act' messages to actors. /act/ messages are something a user
can grasp, e.g /act venti on/. actors are something specific having
their own actor exchanges, e.g /act_433_mhz/ where messages contain
the commands for the sender as payload.
**** Idee
- Jedes event transformiert den aktuellen system state in einen neuen
  (clojure swap! semantik)
- Ändern des systemstates stösst die rule engine an
- Regeln verändern den state nicht (direkt). Können aber events
  emiten.
- State änderungen sind atomar. Ein event verändert. Andere events
  warten die änderungen ab. Änderungen sind ganz oder garnicht.
- Rule engine ausführungen immer auf neuen state. Rule engine
  ausführungen sind unabhängig voneinander
- Was ist mit aktoren?
  - State änderung muss irgendwie auch aktoren triggern können..
  - Hm.
  - State change funktionen für bestimmte events?
    - führen auch aktionen aus?

  - should-be relation:
    - event sagt "an", state sagt "aus" -> an aktion generieren
    - event sagt "an", state sagt "an" -> nop

      #+BEGIN_EXAMPLE
EVENT -> OLD STATE -> STATE CHANGE -> NEW STATE
                       -> ACTIONS

EVENT -> OLD STATE -> STATE CHANGE -> NEW STATE
                                   -> DIFFERENCE OLD NEW
                                   -> ACTIONS

      #+END_EXAMPLE
- Fakten, konfiguration
  - aktor name zu triggernes foo
  - 'act bulb on' -> msg =11111 1 on= an =act_433mhz= exchange.

- =(state-change old)=

*** ASSIGNED openhab integration                                  :@snowball:
*** OPEN irc reader
**** assign voices to each participant
***** parameters
- speed
- pitch
- voice: lea, julia, kenny...
**** participants can change voices

*** OPEN music player daemon                                         :c3po:
- mpd commands als messages
- Story: Ein EDI MQ command kann verschiedene music player daemons steuern
- Probleme
  - Mehrere mpds unterstützen; gleichzeitig steuern?
*** OPEN calendar integration - ics?
- Repeadedly parse calendar files. Idealy ics. Load from caldav?
  google calendar?

**** Variants
***** Calendar Commands
- Im Kallender stehen edi commands. Diese zu den eingestellten Zeiten
  injecten.

Quasi alternative zu CRON.

irq0: Damit koennte ich mir meinen Wecker bauen..

***** Events
- Event :: Something is going to happen at a point in time. Wie das
           digitale Zeitalter..

Per TTS, Text notification, IRC, Jabber whatever hinweisen
** Architecture Changes
*** ASSIGNED list, help messages for 'cmd' exchange                 :@irq0:
Everyone on the cmd exchange should consume list and help messages.

**** Replies
- help :: If "args" = "$0" : Reply with brief usage and supported commands
- list :: Reply with something like "I exist and my name is"

**** Destination

#+BEGIN_SRC clojure
(str/replace (:src msg) #"recv" "send")
#+END_SRC

**** Status
- The newer commands have this build in. Works fine.

*** IDEA state change exchange?
Ohne globalen state müssen state veränderungen irgendwie kommuniziert
werden. Beispiel: user loggt sich ein.

Beispiel:
- user loggt sich ein
- tts begrüssung triggern
- rule engine wertet systemzustand aus


Mögliche umsetzung
/st/ exchange. User presence manager sendet message mit "userloggedin"
oder so an den exchange.

Ein event->tts consumer generiert tts commands wenn nötig

Die rule engine verändert ihren systemzustand und wertet rules neu aus.
** Project Name
- EDI :: ++
- ESI :: Enhanced Subraum Intelligence?
*** Subtitle?
- The hacker (friendly) space automation?
* Documentation
The core of the architecture is the rabbitmq amqp message server.
Every pice of code connects in some way to it.

Most services share a couple of well defined exchanges. See the
[[Well-defined Exchanges]] for a description.

** Glossary
- source :: Apps that only/mainly produce messages
- sink :: Apps that only/mainly consume messages
- processor :: Apps that transform messages. Consume -> Produce.
- bot :: Consumer/Producer that add external/foreign interfaces to the
         system. Like IRC.

** Well-defined Exchanges
https://git.c3pb.de/c3pb/subraum-automatisierung/blob/master/doc/exchanges.jpeg

*** msg
Raw messages received from somewhere. This should be something that
can be parsed to a command.

Type: topic

**** Routing Keys
In general: protocol.bot-name.{send,recv,presence}.channel

 * irc.EDI.recv.#c3pb.sh
 * irc.EDI.send.#c3pb.sh
 * irc.EDI.presence
**** Messages
***** #.send.*
Content-Type: application/json

- msg :: Message body
- user :: Destination user

Content-Type: text/plain
body: Message
***** #.recv.*
Content-Type: application/json
- msg :: Message body
- user :: Message sender
**** Processors
***** parse-commands.py
Transform =!<command>= to *cmd* Messages. (See *cmd* Exchange)

**** Bots
***** IRC Bot - mqbot.py
IRC -> MQ, MQ -> IRC

**** Sinks

**** Sources

*** cmd
Messages that do something :)

Type: topic

**** Known routing Keys

***** TTS
- tts
- say
- forune
***** Actor Service
- act
***** subinit
- telinit
- runlevel
***** thehonestbookoftruth
- login
- logout
- logout-all
- ul
- eta
- uneta
***** What every command should implement:
- list
- help

**** Messages
Content-Type: application/json

- cmd :: Usually the same as the routing key when parsed from *msg*
         Messages. Could be different. Not sure why I include it. The
         clojure tools use the to dispatch handlers..
- args :: Argument string.
- user :: User that send the command. The command may use this to log.
- src :: Command origin. Replies will be send here with the word
         /recv/ replaced by /send/. If the src is invalid replies will
         just vanish :)

**** Sources
**** Sinks
**** Processors
***** tts
Transform /tts/ *cmd* Messages to notification audio messages.

Text -> Audio file.

***** Simple Actor Service - act.py
Map /act/ commands to actors.

Example:
venti on => 433Mhz sender, payload 11111 1 1

See =act_433mhz= exchange for the 433Mhz actor implementation.

*** notify
*Sink* exchage for notifications.

**** Routing Keys
- audio
- text

**** Sinks
***** mplayer one-liner
#+BEGIN_SRC sh
amqp-consume --url="amqp://mopp" --exchange="notify" --routing-key="audio" mplayer -
#+END_SRC

**** Messages
Content-Type depending on exchange keys. Should be directly usable by
the sink (e.g mp3 file to hand over to mplayer).

*** =act_433mhz=                                                  :private:
*Sink* exchange to signal 433mhz transmitter.

Type: fanout

**** Messages
Commandline arguments for `rcswitch-pi`.

**** Sinks
*** subinit                                                       :private:
*Sink* exchange for subinit messages

Type: topic
**** Messages
Content-type: text/plain

Must always contain the same as the routing key.
**** Sinks
***** subinit-rc
Launch scripts on subinit messages consumed. Feel similar to sysvinit
scripts and runlevels

** Software, Libs, etc.
*** Debian packages
- rabbitmq-server (debian testing ist aktuell genug)
- python-pika
- python-amqplib
- amqp-tools

*** docker
For development docker seemes a good choice:
#+BEGIN_SRC sh
sudo docker run -p :5672 -p :15672 -v /scratch/docker-data/rabbitmq:/var/lib/rabbitmq/mnesia f04150b0661e
sudo docker build github.com/mikaelhg/docker-rabbitmq.git
#+END_SRC

Note that the exchanges are configured by hand..

Use =mopp=, running on the dell netbook.
*** Useful libraries

** Development
Install requirements. Setup exchanges in rabbitmq. The web interfaces
comes in handy here ;)

*** Repository Organization
- src :: Tools that only *publish* messages
- sink :: Tools that only *consume* messages
- proc :: Tools that *consume* and *publish* with some kind of
          processing going on
- bot :: Adapter to other protocols like IRC. *publisher* and *consumer*
- demo :: Useful stuff for testing, reference, whatever

Most larger tools are subtree merged from elsewhere. This repo is kind
of the collected deployment branch.

Have something to add? Let me pull your repo!

*** External Documentation
- [[http://www.rabbitmq.com/getstarted.html][Must read rabbitmq tutorial - covers all the basic use cases]]

*** Libraries
**** Python
- pika :: http://pika.readthedocs.org/en/latest/ Documented, Async lib
- amqplib :: simpler non-threaded library; documentation shipped in
             the .py files. Which are quite readable ;)

**** Commandline
- amqp-tools :: Make sure you get the recent ones. Debian testing
                works quite well. Debian stable not so.

**** Clojure
- langohr :: http://clojurerabbitmq.info/ Excellent library.
